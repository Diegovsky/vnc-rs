use crate::{client::messages::ClientMsg, PixelFormat};

#[derive(Clone)]
pub struct ImageData {
    pub rect: Rect,
    pub data: Box<[u8]>,
}

impl std::fmt::Debug for ImageData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ImageData")
            .field("rect", &self.rect)
            .field("data", &"<binary data>")
            .finish()
    }
}

impl ImageData {
    #[inline]
    pub fn new(rect: Rect, data: impl Into<Box<[u8]>>) -> Self {
        Self {
            rect,
            data: data.into(),
        }
    }
}

/// A rect where the image should be updated
#[derive(Debug, Clone, Copy)]
pub struct Rect {
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
}

/// Resolution format to resize window
#[derive(Debug, Clone)]
pub struct Screen {
    pub width: u16,
    pub height: u16,
}

impl From<(u16, u16)> for Screen {
    fn from(tuple: (u16, u16)) -> Self {
        Self {
            width: tuple.0,
            height: tuple.1,
        }
    }
}

type SrcRect = Rect;
type DstRect = Rect;

#[derive(Debug, Clone)]
pub enum VncImageEvent {
    /// Raw image data in the order followed by informed PixelFormat
    RawImage(ImageData),

    /// Copy image data from the second rect to the first
    Copy(DstRect, SrcRect),

    /// A jpeg image if using Tight encoding,
    ///
    /// Encoding the bytes with base64 and render it with "<img src=data:image/jpeg;base64,.../>",
    JpegImage(ImageData),
}

/// Events generated by the [crate::VncClient]
///
#[non_exhaustive]
#[derive(Debug, Clone)]
pub enum VncEvent {
    /// Tell the client how to display the images
    ///
    /// ```no_compile
    /// if let VncEvent::SetResolution(resolution) = event {
    ///     window.resize(screen.width, screen.height);
    /// }
    /// ```
    ///
    /// Note that this event may be recived multiple times
    ///
    /// If the [crate::VncEncoding::DesktopSizePseudo] is set
    SetResolution(Screen),

    /// If the connector doesn't call `set_pixel_format` method
    ///
    /// The engine will generate a [VncEvent::SetPixelFormat] to let the window know how to render image
    SetPixelFormat(PixelFormat),

    /// Tells the client to draw images into it's window.
    ImageEvent(Vec<VncImageEvent>),

    // PngImage(Rect, ImageData),
    /// Will be generated if [crate::VncEncoding::CursorPseudo] is set
    ///
    /// According to [RFC6143, section-7.8.1](https://www.rfc-editor.org/rfc/rfc6143.html#section-7.8.1)
    SetCursor(ImageData),

    /// Just ring a bell
    Bell,

    /// Will be generated everytime the vncserver's clipboarded get updated
    ///
    /// Note that only Latin-1 character set is allowed
    ///
    /// According to [RFC6143](https://www.rfc-editor.org/rfc/rfc6143.html#section-7.6.4)
    Text(String),

    /// If any unexpected error happens in the async process routines
    /// This event will propagate the error to the current context
    Error(String),
}

/// X11 keyboard event to notify the server
///
/// Referring to [RFC6143, section-7.5.4](https://www.rfc-editor.org/rfc/rfc6143.html#section-7.5.4)
///
#[derive(Debug, Clone)]
pub struct ClientKeyEvent {
    pub keycode: u32,
    pub down: bool,
}

impl From<(u32, bool)> for ClientKeyEvent {
    fn from(tuple: (u32, bool)) -> Self {
        Self {
            keycode: tuple.0,
            down: tuple.1,
        }
    }
}

/// X11 mouse event to notify the server
///
/// Referring to [RFC6143, seciont-7.5.5](https://www.rfc-editor.org/rfc/rfc6143.html#section-7.5.5)
///
#[derive(Debug, Clone)]
pub struct ClientMouseEvent {
    pub position_x: u16,
    pub position_y: u16,
    pub bottons: u8,
}

impl From<(u16, u16, u8)> for ClientMouseEvent {
    fn from(tuple: (u16, u16, u8)) -> Self {
        Self {
            position_x: tuple.0,
            position_y: tuple.1,
            bottons: tuple.2,
        }
    }
}

/// Client-side event which used to ask the engine send some command to the vnc server
///
#[non_exhaustive]
#[derive(Debug, Clone)]
pub enum ClientEvent {

    /// Require a frame update
    Refresh,

    /// Key down/up
    KeyEvent(ClientKeyEvent),

    /// Mouse move/up/down/scroll
    PointerEvent(ClientMouseEvent),

    /// Send data to the server's clipboard
    ///
    /// Only Latin-1 character set is allowed
    CopyText(String),
}

impl ClientEvent {
    pub(crate) fn into_msg(self, width: u16, height: u16) -> ClientMsg {
        match self {
            ClientEvent::Refresh => ClientMsg::FramebufferUpdateRequest(
                Rect {
                    x: 0,
                    y: 0,
                    width,
                    height,
                },
                1,
            ),
            ClientEvent::KeyEvent(key) => ClientMsg::KeyEvent(key.keycode, key.down),
            ClientEvent::PointerEvent(mouse) => {
                ClientMsg::PointerEvent(mouse.position_x, mouse.position_y, mouse.bottons)
            }
            ClientEvent::CopyText(text) => ClientMsg::ClientCutText(text),
        }
    }
}
